)]}'
{"version": 3, "sources": ["/web/static/src/legacy/js/services/session.js", "/web/static/src/legacy/js/public/public_root.js", "/web/static/src/legacy/js/public/public_root_instance.js", "/web/static/src/legacy/js/public/public_widget.js", "/web/static/src/legacy/js/report/utils.js", "/web/static/src/legacy/js/report/report.js"], "mappings": "AAAA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxaA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9TA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["odoo.define('web.session', function (require) {\n\"use strict\";\n\nvar Session = require('web.Session');\n\nvar session = new Session(undefined, undefined, {use_cors: false});\nsession.is_bound = session.session_bind();\n\nreturn session;\n\n});\n", "/** @odoo-module alias=web.public.root */\n\nimport ajax from 'web.ajax';\nimport dom from 'web.dom';\nimport env from 'web.public_env';\nimport session from 'web.session';\nimport utils from 'web.utils';\nimport publicWidget from 'web.public.widget';\nimport { registry } from '@web/core/registry';\n\nimport AbstractService from \"web.AbstractService\";\nimport legacyEnv from \"web.public_env\";\nimport lazyloader from \"web.public.lazyloader\";\n\nimport {\n    makeLegacyNotificationService,\n    makeLegacyRpcService,\n    makeLegacySessionService,\n    makeLegacyDialogMappingService,\n    mapLegacyEnvToWowlEnv,\n    makeLegacyRainbowManService,\n} from \"../../utils\";\nimport { ComponentAdapter } from \"web.OwlCompatibility\";\n\nimport { loadBundleTemplates } from \"@web/core/assets\";\nimport { makeEnv, startServices } from \"@web/env\";\nimport { MainComponentsContainer } from \"@web/core/main_components_container\";\nimport { browser } from '@web/core/browser/browser';\nimport { jsonrpc } from '@web/core/network/rpc_service';\nconst serviceRegistry = registry.category(\"services\");\n\n// Load localizations outside the PublicRoot to not wait for DOM ready (but\n// wait for them in PublicRoot)\nfunction getLang() {\n    var html = document.documentElement;\n    return (html.getAttribute('lang') || 'en_US').replace('-', '_');\n}\nvar lang = utils.get_cookie('frontend_lang') || getLang(); // FIXME the cookie value should maybe be in the ctx?\n// momentjs don't have config for en_US, so avoid useless RPC\nvar localeDef = lang !== 'en_US' ? ajax.loadJS('/web/webclient/locale/' + lang.replace('-', '_')) : Promise.resolve();\n\n\n/**\n * Element which is designed to be unique and that will be the top-most element\n * in the widget hierarchy. So, all other widgets will be indirectly linked to\n * this Class instance. Its main role will be to retrieve RPC demands from its\n * children and handle them.\n */\nexport const PublicRoot = publicWidget.RootWidget.extend({\n    events: _.extend({}, publicWidget.RootWidget.prototype.events || {}, {\n        'submit .js_website_submit_form': '_onWebsiteFormSubmit',\n        'click .js_disable_on_click': '_onDisableOnClick',\n    }),\n    custom_events: _.extend({}, publicWidget.RootWidget.prototype.custom_events || {}, {\n        call_service: '_onCallService',\n        context_get: '_onContextGet',\n        main_object_request: '_onMainObjectRequest',\n        widgets_start_request: '_onWidgetsStartRequest',\n        widgets_stop_request: '_onWidgetsStopRequest',\n    }),\n\n    /**\n     * @constructor\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.env = env;\n        this.publicWidgets = [];\n    },\n    /**\n     * @override\n     */\n    willStart: function () {\n        // TODO would be even greater to wait for localeDef only when necessary\n        return Promise.all([\n            this._super.apply(this, arguments),\n            session.is_bound,\n            localeDef\n        ]);\n    },\n    /**\n     * @override\n     */\n    start: function () {\n        var defs = [\n            this._super.apply(this, arguments),\n            this._startWidgets()\n        ];\n\n        // Display image thumbnail\n        this.$(\".o_image[data-mimetype^='image']\").each(function () {\n            var $img = $(this);\n            if (/gif|jpe|jpg|png/.test($img.data('mimetype')) && $img.data('src')) {\n                $img.css('background-image', \"url('\" + $img.data('src') + \"')\");\n            }\n        });\n\n        // Auto scroll\n        if (window.location.hash.indexOf(\"scrollTop=\") > -1) {\n            this.el.scrollTop = +window.location.hash.match(/scrollTop=([0-9]+)/)[1];\n        }\n\n        // Fix for IE:\n        if ($.fn.placeholder) {\n            $('input, textarea').placeholder();\n        }\n\n        this.$el.children().on('error.datetimepicker', this._onDateTimePickerError.bind(this));\n\n        return Promise.all(defs);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Retrieves the global context of the public environment. This is the\n     * context which is automatically added to each RPC.\n     *\n     * @private\n     * @param {Object} [context]\n     * @returns {Object}\n     */\n    _getContext: function (context) {\n        return _.extend({\n            'lang': getLang(),\n        }, context || {});\n    },\n    /**\n     * Retrieves the global context of the public environment (as\n     * @see _getContext) but with extra informations that would be useless to\n     * send with each RPC.\n     *\n     * @private\n     * @param {Object} [context]\n     * @returns {Object}\n     */\n    _getExtraContext: function (context) {\n        return this._getContext(context);\n    },\n    /**\n     * @private\n     * @param {Object} [options]\n     * @returns {Object}\n     */\n    _getPublicWidgetsRegistry: function (options) {\n        return publicWidget.registry;\n    },\n    /**\n     * As the root instance is designed to be unique, the associated\n     * registry has been instantiated outside of the class and is simply\n     * returned here.\n     *\n     * @private\n     * @override\n     */\n    _getRegistry: function () {\n        return registry.category(\"public_root_widgets\");\n    },\n    /**\n     * Creates an PublicWidget instance for each DOM element which matches the\n     * `selector` key of one of the registered widgets\n     * (@see PublicWidget.selector).\n     *\n     * @private\n     * @param {jQuery} [$from]\n     *        only initialize the public widgets whose `selector` matches the\n     *        element or one of its descendant (default to the wrapwrap element)\n     * @param {Object} [options]\n     * @returns {Deferred}\n     */\n    _startWidgets: function ($from, options) {\n        var self = this;\n\n        if ($from === undefined) {\n            $from = this.$('#wrapwrap');\n            if (!$from.length) {\n                // TODO Remove this once all frontend layouts possess a\n                // #wrapwrap element (which is necessary for those pages to be\n                // adapted correctly if the user installs website).\n                $from = this.$el;\n            }\n        }\n\n        options = Object.assign({}, options, {\n            wysiwyg: $('#wrapwrap').data('wysiwyg'),\n        });\n\n        this._stopWidgets($from);\n\n        var defs = _.map(this._getPublicWidgetsRegistry(options), function (PublicWidget) {\n            var selector = PublicWidget.prototype.selector || '';\n            var $target = dom.cssFind($from, selector, true);\n\n            var defs = _.map($target, function (el) {\n                var widget = new PublicWidget(self, options);\n                self.publicWidgets.push(widget);\n                return widget.attachTo($(el));\n            });\n            return Promise.all(defs);\n        });\n        return Promise.all(defs);\n    },\n    /**\n     * Destroys all registered widget instances. Website would need this before\n     * saving while in edition mode for example.\n     *\n     * @private\n     * @param {jQuery} [$from]\n     *        only stop the public widgets linked to the given element(s) or one\n     *        of its descendants\n     */\n    _stopWidgets: function ($from) {\n        var removedWidgets = _.map(this.publicWidgets, function (widget) {\n            if (!$from\n                || $from.filter(widget.el).length\n                || $from.find(widget.el).length) {\n                widget.destroy();\n                return widget;\n            }\n            return null;\n        });\n        this.publicWidgets = _.difference(this.publicWidgets, removedWidgets);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Calls the requested service from the env. Automatically adds the global\n     * context to RPCs.\n     *\n     * @private\n     * @param {OdooEvent} event\n     */\n    _onCallService: function (ev) {\n        function _computeContext(context, noContextKeys) {\n            context = _.extend({}, this._getContext(), context);\n            if (noContextKeys) {\n                context = _.omit(context, noContextKeys);\n            }\n            return JSON.parse(JSON.stringify(context));\n        }\n\n        const payload = ev.data;\n        let args = payload.args || [];\n        if (payload.service === 'ajax' && payload.method === 'rpc') {\n            // ajax service uses an extra 'target' argument for rpc\n            args = args.concat(ev.target);\n\n            var route = args[0];\n            if (_.str.startsWith(route, '/web/dataset/call_kw/')) {\n                var params = args[1];\n                var options = args[2];\n                var noContextKeys;\n                if (options) {\n                    noContextKeys = options.noContextKeys;\n                    args[2] = _.omit(options, 'noContextKeys');\n                }\n                params.kwargs.context = _computeContext.call(this, params.kwargs.context, noContextKeys);\n            }\n        } else if (payload.service === 'ajax' && payload.method === 'loadLibs') {\n            args[1] = _computeContext.call(this, args[1]);\n        } else {\n            return;\n        }\n\n        const service = this.env.services[payload.service];\n        const result = service[payload.method].apply(service, args);\n        payload.callback(result);\n        ev.stopPropagation();\n    },\n    /**\n     * Called when someone asked for the global public context.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onContextGet: function (ev) {\n        if (ev.data.extra) {\n            ev.data.callback(this._getExtraContext(ev.data.context));\n        } else {\n            ev.data.callback(this._getContext(ev.data.context));\n        }\n    },\n    /**\n     * Checks information about the page main object.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onMainObjectRequest: function (ev) {\n        var repr = $('html').data('main-object');\n        var m = repr.match(/(.+)\\((\\d+),(.*)\\)/);\n        ev.data.callback({\n            model: m[1],\n            id: m[2] | 0,\n            viewid: parseInt(document.documentElement.dataset.viewid),\n        });\n    },\n    /**\n     * Called when the root is notified that the public widgets have to be\n     * (re)started.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onWidgetsStartRequest: function (ev) {\n        this._startWidgets(ev.data.$target, ev.data.options)\n            .then(ev.data.onSuccess)\n            .guardedCatch(ev.data.onFailure);\n    },\n    /**\n     * Called when the root is notified that the public widgets have to be\n     * stopped.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onWidgetsStopRequest: function (ev) {\n        this._stopWidgets(ev.data.$target);\n    },\n    /**\n     * @todo review\n     * @private\n     */\n    _onWebsiteFormSubmit: function (ev) {\n        var $buttons = $(ev.currentTarget).find('button[type=\"submit\"], a.a-submit');\n        _.each($buttons, function (btn) {\n            var $btn = $(btn);\n            $btn.prepend('<i class=\"fa fa-circle-o-notch fa-spin\"></i> ');\n            $btn.prop('disabled', true);\n        });\n    },\n    /**\n     * Called when the root is notified that the button should be\n     * disabled after the first click.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onDisableOnClick: function (ev) {\n        $(ev.currentTarget).addClass('disabled');\n    },\n    /**\n     * Library clears the wrong date format so just ignore error\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onDateTimePickerError: function (ev) {\n        return false;\n    },\n});\n\nconst { Component, mount } = owl;\n\n/**\n * Configure Owl with the public env\n */\nowl.config.mode = legacyEnv.isDebug() ? \"dev\" : \"prod\";\nowl.Component.env = legacyEnv;\n\n/**\n * This widget is important, because the tour manager needs a root widget in\n * order to work. The root widget must be a service provider with the ajax\n * service, so that the tour manager can let the server know when tours have\n * been consumed.\n */\nexport async function createPublicRoot(RootWidget) {\n    await lazyloader.allScriptsLoaded;\n    AbstractService.prototype.deployServices(legacyEnv);\n    // add a bunch of mapping services that will redirect service calls from the legacy env\n    // to the wowl env\n    serviceRegistry.add(\"legacy_rpc\", makeLegacyRpcService(legacyEnv));\n    serviceRegistry.add(\"legacy_session\", makeLegacySessionService(legacyEnv, session));\n    serviceRegistry.add(\"legacy_notification\", makeLegacyNotificationService(legacyEnv));\n    serviceRegistry.add(\"legacy_dialog_mapping\", makeLegacyDialogMappingService(legacyEnv));\n    serviceRegistry.add(\"legacy_rainbowman_service\", makeLegacyRainbowManService(legacyEnv));\n    await Promise.all([owl.utils.whenReady(), session.is_bound]);\n\n    // Patch browser.fetch and the rpc service to use the correct base url when\n    // embeded in an external page\n    const baseUrl = session.prefix;\n    const { fetch } = browser;\n    browser.fetch = function(url, ...args) {\n        if (!url.match(/^(?:https?:)?\\/\\//)) {\n            url = baseUrl + url;\n        }\n        return fetch(url, ...args);\n    }\n    serviceRegistry.add(\"rpc\", {\n        async: true,\n        start(env) {\n            let rpcId = 0;\n            return function rpc(route, params = {}, settings) {\n                if (!route.match(/^(?:https?:)?\\/\\//)) {\n                    route = baseUrl + route;\n                }\n                return jsonrpc(env, rpcId++, route, params, settings);\n            };\n        },\n    }, { force: true });\n\n    const wowlEnv = makeEnv();\n    wowlEnv.qweb.addTemplates(await loadBundleTemplates(\"web.assets_frontend\"));\n    await startServices(wowlEnv);\n    mapLegacyEnvToWowlEnv(legacyEnv, wowlEnv);\n\n    const adapter = new ComponentAdapter(null, { Component }); // Used for _trigger_up compat layer\n    const publicRoot = new RootWidget(adapter);\n    await Promise.all([\n        mount(MainComponentsContainer, {\n            target: document.body,\n            env: wowlEnv,\n        }),\n        publicRoot.attachTo(document.body),\n    ]);\n    return publicRoot;\n}\n\nexport default { PublicRoot, createPublicRoot };\n", "/** @odoo-module alias=root.widget */\nimport { PublicRoot, createPublicRoot } from \"./public_root\";\n\nexport default createPublicRoot(PublicRoot);\n", "/** @odoo-module alias=web.public.widget */\n\n/**\n * Provides a way to start JS code for public contents.\n */\n\nimport dom from 'web.dom';\nimport session from 'web.session';\nimport Widget from 'web.Widget';\n\n/**\n * Specialized Widget which automatically instantiates child widgets to attach\n * to internal DOM elements once it is started. The widgets to instantiate are\n * known thanks to a linked registry which contains info about the widget\n * classes and jQuery selectors to use to find the elements to attach them to.\n *\n * @todo Merge with 'PublicWidget' ?\n */\nvar RootWidget = Widget.extend({\n    /**\n     * @constructor\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this._widgets = [];\n    },\n    /**\n     * @override\n     * @see _attachComponents\n     */\n    start: function () {\n        var defs = [this._super.apply(this, arguments)];\n\n        defs.push(this._attachComponents());\n        this._getRegistry().on(\"UPDATE\", this, ({ operation, value }) => {\n            if (operation === \"add\") {\n                this._attachComponent(value);\n            }\n        });\n\n        return Promise.all(defs);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Instantiates a child widget according to the given registry data.\n     *\n     * @private\n     * @param {Object} childInfo\n     * @param {function} childInfo.Widget - the widget class to instantiate\n     * @param {string} childInfo.selector\n     *        the jQuery selector to use to find the internal DOM element which\n     *        needs to be attached to the instantiated widget\n     * @param {jQuery} [$from] - only check DOM elements which are descendant of\n     *                         the given one. If not given, use this.$el.\n     * @returns {Deferred}\n     */\n    _attachComponent: function (childInfo, $from) {\n        var self = this;\n        var $elements = dom.cssFind($from || this.$el, childInfo.selector);\n        var defs = _.map($elements, function (element) {\n            var w = new childInfo.Widget(self);\n            self._widgets.push(w);\n            return w.attachTo(element);\n        });\n        return Promise.all(defs);\n    },\n    /**\n     * Instantiates the child widgets that need to be according to the linked\n     * registry.\n     *\n     * @private\n     * @param {jQuery} [$from] - only check DOM elements which are descendant of\n     *                         the given one. If not given, use this.$el.\n     * @returns {Deferred}\n     */\n    _attachComponents: function ($from) {\n        var self = this;\n        var childInfos = this._getRegistry().getAll();\n        var defs = _.map(childInfos, function (childInfo) {\n            return self._attachComponent(childInfo, $from);\n        });\n        return Promise.all(defs);\n    },\n    /**\n     * Returns the `RootWidgetRegistry` instance that is linked to this\n     * `RootWidget` instance.\n     *\n     * @abstract\n     * @private\n     * @returns {RootWidgetRegistry}\n     */\n    _getRegistry: function () {},\n});\n\n//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\n/**\n * Provides a way for executing code once a website DOM element is loaded in the\n * dom.\n */\nvar PublicWidget = Widget.extend({\n    /**\n     * The selector attribute, if defined, allows to automatically create an\n     * instance of this widget on page load for each DOM element which\n     * matches this selector. The `PublicWidget.$target` element will then be\n     * that particular DOM element. This should be the main way of instantiating\n     * `PublicWidget` elements.\n     *\n     * @todo do not make this part of the Widget but rather an info to give when\n     * registering the widget.\n     */\n    selector: false,\n    /**\n     * Extension of @see Widget.events\n     *\n     * A description of the event handlers to bind/delegate once the widget\n     * has been rendered::\n     *\n     *   'click .hello .world': 'async _onHelloWorldClick',\n     *     _^_      _^_           _^_        _^_\n     *      |        |             |          |\n     *      |  (Optional) jQuery   |  Handler method name\n     *      |  delegate selector   |\n     *      |                      |_ (Optional) space separated options\n     *      |                          * async: use the automatic system\n     *      |_ Event name with           making handlers promise-ready (see\n     *         potential jQuery          makeButtonHandler, makeAsyncHandler)\n     *         namespaces\n     *\n     * Note: the values may be replaced by a function declaration. This is\n     * however a deprecated behavior.\n     *\n     * @type {Object}\n     */\n    events: {},\n\n    /**\n     * @constructor\n     * @param {Object} parent\n     * @param {Object} [options]\n     */\n    init: function (parent, options) {\n        this._super.apply(this, arguments);\n        this.options = options || {};\n    },\n    /**\n     * Destroys the widget and basically restores the target to the state it\n     * was before the start method was called (unlike standard widget, the\n     * associated $el DOM is not removed, if this was instantiated thanks to the\n     * selector property).\n     */\n    destroy: function () {\n        if (this.selector) {\n            var $oldel = this.$el;\n            // The difference with the default behavior is that we unset the\n            // associated element first so that:\n            // 1) its events are unbinded\n            // 2) it is not removed from the DOM\n            this.setElement(null);\n        }\n\n        this._super.apply(this, arguments);\n\n        if (this.selector) {\n            // Reassign the variables afterwards to allow extensions to use them\n            // after calling the _super method\n            this.$el = $oldel;\n            this.el = $oldel[0];\n            this.$target = this.$el;\n            this.target = this.el;\n        }\n    },\n    /**\n     * @override\n     */\n    setElement: function () {\n        this._super.apply(this, arguments);\n        if (this.selector) {\n            this.$target = this.$el;\n            this.target = this.el;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @see this.events\n     * @override\n     */\n    _delegateEvents: function () {\n        var self = this;\n        var originalEvents = this.events;\n\n        var events = {};\n        _.each(this.events, function (method, event) {\n            // If the method is a function, use the default Widget system\n            if (typeof method !== 'string') {\n                events[event] = method;\n                return;\n            }\n            // If the method is only a function name without options, use the\n            // default Widget system\n            var methodOptions = method.split(' ');\n            if (methodOptions.length <= 1) {\n                events[event] = method;\n                return;\n            }\n            // If the method has no meaningful options, use the default Widget\n            // system\n            var isAsync = _.contains(methodOptions, 'async');\n            if (!isAsync) {\n                events[event] = method;\n                return;\n            }\n\n            method = self.proxy(methodOptions[methodOptions.length - 1]);\n            if (_.str.startsWith(event, 'click')) {\n                // Protect click handler to be called multiple times by\n                // mistake by the user and add a visual disabling effect\n                // for buttons.\n                method = dom.makeButtonHandler(method);\n            } else {\n                // Protect all handlers to be recalled while the previous\n                // async handler call is not finished.\n                method = dom.makeAsyncHandler(method);\n            }\n            events[event] = method;\n        });\n\n        this.events = events;\n        this._super.apply(this, arguments);\n        this.events = originalEvents;\n    },\n    /**\n     * @private\n     * @param {boolean} [extra=false]\n     * @param {Object} [extraContext]\n     * @returns {Object}\n     */\n    _getContext: function (extra, extraContext) {\n        var context;\n        this.trigger_up('context_get', {\n            extra: extra || false,\n            context: extraContext,\n            callback: function (ctx) {\n                context = ctx;\n            },\n        });\n        return context;\n    },\n});\n\n//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\n/**\n * The registry object contains the list of widgets that should be instantiated\n * thanks to their selector property if any.\n */\nvar registry = {};\n\n/**\n * This is a fix for apple device (<= IPhone 4, IPad 2)\n * Standard bootstrap requires data-toggle='collapse' element to be <a/> tags.\n * Unfortunatly some layouts use a <div/> tag instead. The fix forces an empty\n * click handler on these div, which allows standard bootstrap to work.\n */\nregistry._fixAppleCollapse = PublicWidget.extend({\n    selector: 'div[data-toggle=\"collapse\"]',\n    events: {\n        'click': function () {},\n    },\n});\n\n// TODO: remove this code in master and put it in its own file.\nregistry.login = PublicWidget.extend({\n    selector: '.oe_login_form',\n    events: {\n        'submit': '_onSubmit',\n    },\n\n    //-------------------------------------------------------------------------\n    // Handlers\n    //-------------------------------------------------------------------------\n\n    /**\n     * Prevents the user from crazy clicking:\n     * Gives the button a loading effect if preventDefault was not already\n     * called and modifies the preventDefault function of the event so that the\n     * loading effect is removed if preventDefault() is called in a following\n     * customization.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onSubmit(ev) {\n        if (!ev.isDefaultPrevented()) {\n            const btnEl = ev.currentTarget.querySelector('button[type=\"submit\"]');\n            const removeLoadingEffect = dom.addButtonLoadingEffect(btnEl);\n            const oldPreventDefault = ev.preventDefault.bind(ev);\n            ev.preventDefault = () => {\n                removeLoadingEffect();\n                oldPreventDefault();\n            };\n        }\n    },\n});\n\nexport default {\n    RootWidget: RootWidget,\n    Widget: PublicWidget,\n    registry: registry,\n};\n", "odoo.define('report.utils', function (require) {\n'use strict';\n\nfunction get_protocol_from_url (url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.protocol;\n}\n\nfunction get_host_from_url (url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a.host;\n}\n\nfunction build_origin (protocol, host) {\n    return protocol + '//' + host;\n}\n\nreturn {\n    'get_protocol_from_url': get_protocol_from_url,\n    'get_host_from_url': get_host_from_url,\n    'build_origin': build_origin,\n};\n\n});\n", "odoo.define('report', function (require) {\n'use strict';\n\nrequire('web.dom_ready');\nvar utils = require('report.utils');\n\nif (window.self === window.top) {\n    return;\n}\n\n$(document.body)\n    .addClass('o_in_iframe')\n    .addClass('container-fluid')\n    .removeClass('container');\n\nvar web_base_url = window.origin;\nvar trusted_host = utils.get_host_from_url(web_base_url);\nvar trusted_protocol = utils.get_protocol_from_url(web_base_url);\nvar trusted_origin = utils.build_origin(trusted_protocol, trusted_host);\n\n// Allow sending commands to the webclient\n// `do_action` command\n$('[res-id][res-model][view-type]')\n    .wrap('<a/>')\n    .attr('href', '#')\n    .on('click', function (ev) {\n        ev.preventDefault();\n        var action = {\n            'type': 'ir.actions.act_window',\n            'view_mode': $(this).attr('view-mode') || $(this).attr('view-type'),\n            'res_id': Number($(this).attr('res-id')),\n            'res_model': $(this).attr('res-model'),\n            'views': [\n                [$(this).attr('view-id') || false, $(this).attr('view-type')],\n            ],\n        };\n        window.parent.postMessage({\n            'message': 'report:do_action',\n            'action': action,\n        }, trusted_origin);\n    });\n});\n"], "file": "/web/assets/757-7041605/web.report_assets_common.js", "sourceRoot": "../../../"}